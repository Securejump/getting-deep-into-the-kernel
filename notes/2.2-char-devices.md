sources:
- Linux Device Drivers - Character drivers, chapter 3.

ever used /dev/null? /dev/zero? those are character devices.

# major-minor values.
```
/*
 * the major-minor values are used for different things.
 * @major: identifies the driver associated with the device.
 *      example: /dev/null are managed by driver 1, and 
 *      /dev/vcs# are managed by driver 7.
 *
 * @minor: used by the kernel to determine exactly which device
 *      is being referred to, or in some cases the device number.
 *
 */
major-minor allocation.
* "Linux Device Drivers" chapter 3 page 48.
* if (scull_major) {
*      dev = MKDEV(scull_major, scull_minor);
                 /*
                 * if the device major value are available, or
                 * we know which major value we need to use,
                 * we'll use the register_chrdev_region function.
                 * 
                 */
*      result = register_chrdev_region(dev, scull_nr_devs, "scull");
* } else {
* now, if we don't know which major values we
 * need, the alloc_chrdev_region function must be used.
 * then, we use the MAJOR() and MINOR() macros to obtain
 * the values given to us. usually, we want to have a major
 * number assigned to our drivers. relying on random major numbers
 * might lead to issues. extract from "Linux Device Drivers":
 *
 * Some major device numbers are statically assigned to the most common devices. A
 * list of those devices can be found in Documentation/devices.txt within the kernel
 * source tree. The chances of a static number having already been assigned for the use
 * of your new driver are small, however, and new numbers are not being assigned. So,
 * as a driver writer, you have a choice: you can simply pick a number that appears to
 * be unused, or you can allocate major numbers in a dynamic manner. Picking a num-
 * ber may work as long as the only user of your driver is you; once your driver is more
 * widely deployed, a randomly picked major number will lead to conflicts and trouble.
 *
 * Thus, for **new drivers**, we strongly suggest that you use dynamic allocation to obtain
 * your major device number, rather than choosing a number randomly from the ones
 * that are currently free. In other words, your drivers should almost certainly be using
 * alloc_chrdev_region rather than register_chrdev_region.
 *
 * The **disadvantage of dynamic assignment is that you can’t create the device nodes in
 * advance**, because the major number assigned to your module will vary. For normal
 * use of the driver, this is hardly a problem, because once the number has been
 * assigned, you can read it from /proc/devices
 * 
 */
*      result = alloc_chrdev_region(&dev, scull_minor, scull_nr_devs, "scull");
* }
```

# important data structures

## file_operations structure

this structure is used to connect our device driver functions to the user. this structure is typically a collection of function pointers. conventionally, the structure's name is usually "fops" or something along those lines.

```
struct module *owner
  The first file_operations field is not an operation at all; it is a pointer to the
  module that “owns” the structure. This field is used to prevent the module from
  being unloaded while its operations are in use. Almost all the time, it is simply
  initialized to THIS_MODULE, a macro defined in <linux/module.h>.
loff_t (*llseek) (struct file *, loff_t, int);
  The llseek method is used to change the current read/write position in a file, and
  the new position is returned as a (positive) return value. The loff_t parameter is
  a “long offset” and is at least 64 bits wide even on 32-bit platforms. Errors are
  signaled by a negative return value. If this function pointer is NULL, seek calls will
  modify the position counter in the file structure (described in the section “The
  file Structure”) in potentially unpredictable ways.
ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
  Used to retrieve data from the device. A null pointer in this position causes the
  read system call to fail with -EINVAL (“Invalid argument”). A nonnegative return
  value represents the number of bytes successfully read (the return value is a
  “signed size” type, usually the native integer type for the target platform).
ssize_t (*aio_read)(struct kiocb *, char __user *, size_t, loff_t);
  Initiates an asynchronous read—a read operation that might not complete
  before the function returns. If this method is NULL, all operations will be pro-
  cessed (synchronously) by read instead.
ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
  Sends data to the device. If NULL, -EINVAL is returned to the program calling the
  write system call. The return value, if nonnegative, represents the number of
  bytes successfully written.
ssize_t (*aio_write)(struct kiocb *, const char __user *, size_t, loff_t *);
  Initiates an asynchronous write operation on the device.
int (*readdir) (struct file *, void *, filldir_t);
  This field should be NULL for device files; it is used for reading directories and is
  useful only for filesystems.
unsigned int (*poll) (struct file *, struct poll_table_struct *);
  The poll method is the back end of three system calls: poll, epoll, and select, all of
  which are used to query whether a read or write to one or more file descriptors
  would block. The poll method should return a bit mask indicating whether non-
  blocking reads or writes are possible, and, possibly, provide the kernel with
  information that can be used to put the calling process to sleep until I/O
  becomes possible. If a driver leaves its poll method NULL, the device is assumed to
  be both readable and writable without blocking.
int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);
  The ioctl system call offers a way to issue device-specific commands (such as for-
  matting a track of a floppy disk, which is neither reading nor writing). Addition-
  ally, a few ioctl commands are recognized by the kernel without referring to the
  fops table. If the device doesn’t provide an ioctl method, the system call returns
  an error for any request that isn’t predefined (-ENOTTY, “No such ioctl for
  device”).
int (*mmap) (struct file *, struct vm_area_struct *);
  mmap is used to request a mapping of device memory to a process’s address
  space. If this method is NULL, the mmap system call returns -ENODEV.
int (*open) (struct inode *, struct file *);
  Though this is always the first operation performed on the device file, the driver
  is not required to declare a corresponding method. If this entry is NULL, opening
  the device always succeeds, but your driver isn’t notified.
int (*flush) (struct file *);
  The flush operation is invoked when a process closes its copy of a file descriptor
  for a device; it should execute (and wait for) any outstanding operations on the
  device. This must not be confused with the fsync operation requested by user
  programs. Currently, flush is used in very few drivers; the SCSI tape driver uses
  it, for example, to ensure that all data written makes it to the tape before the
  device is closed. If flush is NULL, the kernel simply ignores the user application
  request.
int (*release) (struct inode *, struct file *);
  This operation is invoked when the file structure is being released. Like open,
  release can be NULL. *
int (*fsync) (struct file *, struct dentry *, int);
  This method is the back end of the fsync system call, which a user calls to flush
  any pending data. If this pointer is NULL, the system call returns -EINVAL.
int (*aio_fsync)(struct kiocb *, int);
  This is the asynchronous version of the fsync method.
int (*fasync) (int, struct file *, int);
  This operation is used to notify the device of a change in its FASYNC flag. Asyn-
  chronous notification is an advanced topic and is described in Chapter 6. The
  field can be NULL if the driver doesn’t support asynchronous notification.
int (*lock) (struct file *, int, struct file_lock *);
  The lock method is used to implement file locking; locking is an indispensable
  feature for regular files but is almost never implemented by device drivers.
ssize_t (*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);
ssize_t (*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);
  These methods implement scatter/gather read and write operations. Applica-
  tions occasionally need to do a single read or write operation involving multiple
  memory areas; these system calls allow them to do so without forcing extra copy
  operations on the data. If these function pointers are left NULL, the read and write
  methods are called (perhaps more than once) instead.
ssize_t (*sendfile)(struct file *, loff_t *, size_t, read_actor_t, void *);
  This method implements the read side of the sendfile system call, which moves
  the data from one file descriptor to another with a minimum of copying. It is
  used, for example, by a web server that needs to send the contents of a file out a
  network connection. Device drivers usually leave sendfile NULL.
ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *,
int);
  sendpage is the other half of sendfile; it is called by the kernel to send data, one
  page at a time, to the corresponding file. Device drivers do not usually imple-
  ment sendpage.
unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned
long, unsigned long, unsigned long);
  The purpose of this method is to find a suitable location in the process’s address
  space to map in a memory segment on the underlying device. This task is nor-
  mally performed by the memory management code; this method exists to allow
  drivers to enforce any alignment requirements a particular device may have.
  Most drivers can leave this method NULL.
int (*check_flags)(int)
  This method allows a module to check the flags passed to an fcntl(F_SETFL...)
  call.
int (*dir_notify)(struct file *, unsigned long);
  This method is invoked when an application uses fcntl to request directory
  change notifications. It is useful only to filesystems; drivers need not implement
  dir_notify.
```

## file structure

the file struct (not to be confused with FILE seen in userspace programs, which is implemented by C libraries and never seen in kernel code) represents an open file. 
not specific to device drivers: every open file in the system has an associated struct file in kernelspace. it's created by the kernel on open and passed to any function that operates on the file until the last close. after all instances of the file are closed, the kernel releases the data structure.
in kernel code, a struct file pointer is usually called a file or filp ("file pointer"). 
we'll reffer to the file pointer as filp, and file to the file structure.
now we'll see the most important fields of the struct file:

```
mode_t f_mode;
  The file mode identifies the file as either readable or writable (or both), by means
  of the bits FMODE_READ and FMODE_WRITE. You might want to check this field for
  read/write permission in your open or ioctl function, but you don’t need to check
  permissions for read and write, because the kernel checks before invoking your
  method. An attempt to read or write when the file has not been opened for that
  type of access is rejected without the driver even knowing about it.
loff_t f_pos;
  The current reading or writing position. loff_t is a 64-bit value on all platforms
  (long long in gcc terminology). The driver can read this value if it needs to know
  the current position in the file but should not normally change it; read and write
  should update a position using the pointer they receive as the last argument
  instead of acting on filp->f_pos directly. The one exception to this rule is in the
  llseek method, the purpose of which is to change the file position.
unsigned int f_flags;
  These are the file flags, such as O_RDONLY, O_NONBLOCK, and O_SYNC. A driver should
  check the O_NONBLOCK flag to see if nonblocking operation has been requested (we
  discuss nonblocking I/O in the section “Blocking and Nonblocking Operations”
  in Chapter 1); the other flags are seldom used. In particular, read/write permis-
  sion should be checked using f_mode rather than f_flags. All the flags are
  defined in the header <linux/fcntl.h>.
struct file_operations *f_op;
  The operations associated with the file. The kernel assigns the pointer as part of
  its implementation of open and then reads it when it needs to dispatch any oper-
  ations. The value in filp->f_op is never saved by the kernel for later reference;
  this means that you can change the file operations associated with your file, and
  the new methods will be effective after you return to the caller. For example, the
  code for open associated with major number 1 (/dev/null, /dev/zero, and so on)
  substitutes the operations in filp->f_op depending on the minor number being
  opened. This practice allows the implementation of several behaviors under the
  same major number without introducing overhead at each system call. The abil-
  ity to replace the file operations is the kernel equivalent of “method overriding”
  in object-oriented programming.
void *private_data;
  The open system call sets this pointer to NULL before calling the open method for
  the driver. You are free to make its own use of the field or to ignore it; you can
  use the field to point to allocated data, but then you must remember to free that
  memory in the release method before the file structure is destroyed by the ker-
  nel. private_data is a useful resource for preserving state information across sys-
  tem calls and is used by most of our sample modules.
struct dentry *f_dentry;
  The directory entry (dentry) structure associated with the file. Device driver writ-
  ers normally need not concern themselves with dentry structures, other than to
  access the inode structure as filp->f_dentry->d_inode.
inode structure
the inode structure is used by the kernel internally to represent files. thus, it is different from the file structure that represents an open file descriptor. there can be numerous file structures representing multiple open descriptors on a single file, but they all point to a single inode structure.
in driver code, we only concern ourselves with these two fields:
dev_t i_rdev;
  For inodes that represent device files, this field contains the actual device number.
struct cdev *i_cdev;
  struct cdev is the kernel’s internal structure that represents char devices; this
  field contains a pointer to that structure when the inode refers to a char device
  file.
```

for better portability when changes to i_rdev or other values might happen, it is recommended to use the following macros:

```
unsigned int iminor(struct inode *inode);
unsigned int imajor(struct inode *inode);
```

in the interest of not being caught by the next change, these macros should be used instead of manipulating i_rdev directly.

