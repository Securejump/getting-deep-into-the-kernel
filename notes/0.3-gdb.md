# issues i found.

## breaking without MMU and page tables.

i'm fairly accostumed to using breakpoints. nevertheless, if no virtual memory is already setup'd (?) and allocated, an issue like this:

```
(gdb) break _printk
Breakpoint 1 at 0xffffffff8121cd70: file kernel/printk/printk.c, line 2470.
(gdb) c
Continuing.
Warning:
Cannot insert breakpoint 1.
Cannot access memory at address 0xffffffff8121cd70

Command aborted.
```

will happen during boot. it happened to me while trying to learn how the kernel boots, what it does, what's the execution flow, such and such.
the solution is fairly simple, though. we just need to use a hardware-assisted breakpoint. that is...

```
(gdb) hbreak _printk
Note: breakpoint 1 also set at pc 0xffffffff8121cd70.
Hardware assisted breakpoint 2 at 0xffffffff8121cd70: file kernel/printk/printk.c, line 2470.
(gdb) c
Continuing.

Breakpoint 2, _printk (fmt=fmt@entry=0xffffffff84800a20 "\0015%s") at kernel/printk/printk.c:2470
2470	{
(gdb)
```

# useful commands

when you want to inspect a memory address that you _know_ beforehand is a piece of code, use the following command:

```
(gdb) list *(0xffffffff84800a20)
...
```
